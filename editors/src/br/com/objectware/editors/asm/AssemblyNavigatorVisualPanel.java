/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package br.com.objectware.editors.asm;

import br.com.objectware.commons.i18n.I18N;
import br.com.objectware.commons.utils.Default;
import br.com.objectware.commons.utils.TextUtil;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import javax.swing.Icon;
import javax.swing.JEditorPane;
import javax.swing.JTree;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.text.BadLocationException;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeSelectionModel;
import org.openide.cookies.EditorCookie;
import org.openide.filesystems.FileObject;
import org.openide.loaders.DataObject;
import org.openide.nodes.Node;
import org.openide.windows.TopComponent;

/**
 *
 * @author Luciano M. Christofoletti <luciano@objectware.net>
 * 
 * Labels: (see https://bitbucket.org/grauw/glass)
 * 
 * Labels and other identifiers follow the following grammar:
 *     identifier = id_start_char id_char*
 *     id_start_char = [a-z] | [A-Z] | _ | . | ? | @
 *     id_char = id_start_char | [0-9] | $ | '
 * 
 * The colon after a label is optional.
 * If a label has no colon, it can not have any leading white space, it must start at column 0.
 */
public class AssemblyNavigatorVisualPanel extends javax.swing.JPanel
        implements Runnable, TreeSelectionListener, DocumentListener, PropertyChangeListener {
    
    /** The data object to be explored in the navigator panel */
    private DataObject dataObject;
    
    /** The current document being editted */
    private javax.swing.text.Document document;
    
    /** The updating document label tree flag */
    private boolean updating = false;
    
    /**
     * Creates new form AssemblyNavigatorVisualPanel
     */
    public AssemblyNavigatorVisualPanel() {
        this.initComponents();
        this.setNavigatorTreeProperties();
    }   
    
    /**
     * Setup the navigator tree properties (behaviour and visual).
     */
    private void setNavigatorTreeProperties() {
        
        this.navigatorTree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
        this.navigatorTree.addTreeSelectionListener(this);
        
        this.navigatorTree.setCellRenderer(new DefaultTreeCellRenderer() {
            
            private final Icon rootIcon = I18N.getImageIcon("source.file.tree.icon");
            private final Icon labelIcon = I18N.getImageIcon("source.label.tree.icon");
            
            @Override
            public java.awt.Component getTreeCellRendererComponent(JTree tree,
                    Object value, boolean selected, boolean expanded,
                    boolean isLeaf, int row, boolean focused) {
                
                java.awt.Component component = super.getTreeCellRendererComponent(tree, value,
                        selected, expanded, isLeaf, row, focused);
                
                if (isLeaf && row > 0) {
                    this.setIcon(this.labelIcon);
                } else {
                    this.setIcon(this.rootIcon);
                }
                
                return component;
            }   
        });
        
        // listen to changes in the Top Component registry
        TopComponent.getRegistry().addPropertyChangeListener(this);
    }   
    
    /**
     * Sets the data object to be displayed in the navigator panel
     * @param dataObject the data object to be scanned
     */
    protected void setDataObject(DataObject dataObject) {
        
        if(dataObject != null) {
            this.dataObject = dataObject;
            synchronized(this) {
                javax.swing.SwingUtilities.invokeLater(this);
            }   
        } else {
            this.navigatorTree.setModel(null);
        }   
        
        // this is necessary for opened documents at the IDE startup
        this.updateDocumentListenerSwingThread();
        //this.updateDocumentListener();////////////////////////////////////////////////////////////////////////////////
    }   
    
    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The
     * content of this method is always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        treeScrollPane = new javax.swing.JScrollPane();
        navigatorTree = new javax.swing.JTree();

        setLayout(new java.awt.BorderLayout());

        javax.swing.tree.DefaultMutableTreeNode treeNode1 = new javax.swing.tree.DefaultMutableTreeNode("root");
        navigatorTree.setModel(new javax.swing.tree.DefaultTreeModel(treeNode1));
        treeScrollPane.setViewportView(navigatorTree);

        add(treeScrollPane, java.awt.BorderLayout.CENTER);
    }// </editor-fold>//GEN-END:initComponents
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTree navigatorTree;
    private javax.swing.JScrollPane treeScrollPane;
    // End of variables declaration//GEN-END:variables
    
    @Override
    public void valueChanged(TreeSelectionEvent event) {
        
        // get the selected node
        Object selectedComponent = this.navigatorTree.getLastSelectedPathComponent();
        DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode) selectedComponent;
        
        if(treeNode != null) {
            
            // if the selected node is not the root node, that is, a leaf...
            Object userObject = treeNode.getUserObject();
            if (treeNode.isLeaf() && userObject instanceof LabelWrapper) {
                this.selectLabelInEditor((LabelWrapper) treeNode.getUserObject());
            }   
        }   
    }   
    
    @Override
    public synchronized void run() {
        
        // if there is an update being done, just return (avoid concurrency update)
        if(this.updating) {
            return;
        }   
        
        // start of update process
        this.updating = true;
        
        try {
            // get the source file reference
            FileObject sourceFile = this.dataObject.getPrimaryFile();
            java.util.List<String> lines = java.util.Collections.emptyList();
            
            // try to get data from editor panel, if available
            JEditorPane editorPanel = this.getEditorPanel();
            if(editorPanel != null) {
                lines = this.getDocumentText(editorPanel.getDocument());
            }   
            
            // try to get data from file if document is empty
            if(lines.isEmpty()) {
                lines = sourceFile.asLines();
            }   
            
            // create the root node
            DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode(sourceFile.getNameExt());
            int currentPosition = 0;
            int lineNumber = 1;
            
            // the set of labels must be sorted
            java.util.Set<LabelWrapper> labels = new java.util.TreeSet<>();
            
            // search for valid labels in all lines
            for(String line:lines) {
                
                String label = this.parseLabel(line);
                if(!label.isEmpty()) {
                    
                    // create the line wrapper
                    LabelWrapper lineWrapper = new LabelWrapper(label, currentPosition);
                    lineWrapper.setLine(lineNumber);
                    
                    labels.add(lineWrapper);
                }   
                
                // update the line and start label position values (plus 1 for line feed)
                currentPosition += (line.length() + 1);
                lineNumber++;
            }   
            
            // add all labels (sorted) to the root node
            for(LabelWrapper label : labels) {
                rootNode.add(new DefaultMutableTreeNode(label));
            }   
            
            // set the tree model for labels selection
            this.navigatorTree.setModel(new DefaultTreeModel(rootNode));
            
        } catch (java.io.IOException ioException) {
            
            // set the null tree model
            this.navigatorTree.setModel(null);
            
        } finally {
            
            // end of update process
            this.updating = false;
        }   
    }   
    
    /**
     * Return the label of the current line or an empty string if the label is not valid.
     * @param line the line where the label is
     * 
     * @return the label of the line
     */
    private String parseLabel(String line) {
        
        // assume there is no valid label (default value)
        String label = Default.EMPTY_STRING;
        
        // verify if the first char of the line is a white space
        boolean hasLeadingWhiteSpace = TextUtil.beginWithWhitespace(line);
        
        // replace all tabs from original line with spaces and trim the result
        String result = line.replace(Default.TAB_CHAR, Default.SPACE_CHAR).trim();
        
        // if the current trimmed result is empty, there is no label available
        // also, the resulting string must start with a "valid" char (see isIdentifierStart())
        if(!result.isEmpty() && isIdentifierStart(result.charAt(0))) {
            
            // discard all chars after the first space (if present)
            result = result.split(Default.SPACE_STRING)[0];
            
            // the label is invalid if it has leading white space and does not have a colon
            if(!hasLeadingWhiteSpace || result.contains(Default.COLOM_STRING)) {
                
                // get all chars from left side of the label separator (if present)
                label = result.split(Default.COLOM_STRING)[0];
                
                // validate the chars of the label
                for(char character:label.toCharArray()) {
                    if(!this.isIdentifier(character)) {
                        label = Default.EMPTY_STRING;
                        break;
                    }
                }
            }
        }   
        
        // return the label (or an empty string)
        return label;
    }
    
    /**
     * Verify if the given character is a valid char for a label.
     * @param character
     * @return 
     */
    private boolean isIdentifier(char character) {
        return isIdentifierStart(character) || ("0123456789$\\".indexOf(character) != -1);
    }   
    
    /**
     * Verify if the given character is a valid start of a label.
     * @param character
     * @return 
     */
    private boolean isIdentifierStart(char character) {
        char lowerCaseChar = Character.toLowerCase(character);
        return (lowerCaseChar >= 'a' && lowerCaseChar <= 'z') || ("_.?@".indexOf(character) != -1);
    }   
    
    /**
     * Set the current line in editor as the line of the selected label.
     * @param labelWrapper the label info
     */
    private void selectLabelInEditor(LabelWrapper labelWrapper) {
        
        // current nodes in the application lookup
        try {
            JEditorPane editorPane = this.getEditorPanel();
            if(editorPane != null) {
                editorPane.setCaretPosition(labelWrapper.getPosition());
            }   
        } catch (java.lang.IllegalArgumentException exception) {
            java.awt.Toolkit.getDefaultToolkit().beep();
        }   
    }   
    
    /**
     * Return the text in the document
     * @param document
     * @return 
     */
    private java.util.List<String> getDocumentText(javax.swing.text.Document document) {
        try {
            String documentText = document.getText(0, document.getLength());
            return java.util.Arrays.asList(documentText.split(Default.LF));
        } catch (BadLocationException exception) {
            return java.util.Collections.emptyList();
        }   
    }   
    
    @Override
    public void insertUpdate(DocumentEvent documentEvent) {
        this.changedUpdate(documentEvent);
    }   
    
    @Override
    public void removeUpdate(DocumentEvent documentEvent) {
        this.changedUpdate(documentEvent);
    }   
    
    @Override
    public void changedUpdate(DocumentEvent documentEvent) {
        synchronized(this) {
            // update the tree labels
            javax.swing.SwingUtilities.invokeLater(this);
        }   
    }   
    
    /**
     * Listener for TopComponent selection changes
     * @param event 
     */
    @Override
    public void propertyChange(PropertyChangeEvent event) {
        if(event.getPropertyName().equals(TopComponent.Registry.PROP_ACTIVATED)) {
            this.updateDocumentListenerSwingThread();
        }   
    }   
    
    /**
     * Auxiliary method to execute the update document listener inside a swing thread
     */
    private void updateDocumentListenerSwingThread() {
        javax.swing.SwingUtilities.invokeLater(this::updateDocumentListener);
    }   
    
    /**
     * Update the document listener
     */
    private void updateDocumentListener() {
        
        // remove the old document listener reference
        if(this.document != null) {
            this.document.removeDocumentListener(this);
        }   
        
        // update the document and the document listener references
        JEditorPane editorPanel = this.getEditorPanel();
        if(editorPanel != null) {
            this.document = editorPanel.getDocument();
            this.document.addDocumentListener(this);
        }   
    }   
    
    /**
     * Get the current selected editor panel (if available).
     * @return 
     */
    private JEditorPane getEditorPanel() {
        
        // current nodes in the application lookup
        Node[] nodes = TopComponent.getRegistry().getCurrentNodes();
        
        // look for nodes only when there is some node available
        if(nodes != null) {
            
            // get the editor that is showing the source file
            for (Node node : nodes) {
                EditorCookie cookie = node.getLookup().lookup(EditorCookie.class);
                if (cookie != null) {
                    JEditorPane[] panes = cookie.getOpenedPanes();
                    if (panes instanceof JEditorPane[] && panes.length > 0) {
                        return panes[0];
                    }   
                }   
            } // end of for
        }
        
        return null;
    }   
    
} // end of class
