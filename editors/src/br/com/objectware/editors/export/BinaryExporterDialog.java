/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package br.com.objectware.editors.export;

import br.com.objectware.commons.i18n.I18N;
import br.com.objectware.commons.utils.Default;
import br.com.objectware.commons.utils.FileUtil;
import br.com.objectware.domain.enums.DataFormat;
import br.com.objectware.domain.enums.ExportFormat;
import br.com.objectware.domain.enums.FileType;
import br.com.objectware.editors.binary.BinaryDataObject;
import br.com.objectware.editors.enums.ExportDialogAction;
import br.com.objectware.ioutils.binary.BinaryFileIOUtil;
import br.com.objectware.ioutils.text.DataFileIOUtil;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.List;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileNameExtensionFilter;
import org.openide.util.Lookup;
import org.openide.windows.WindowManager;

/**
 * Binary data export dialog. Defines all export options.
 * 
 * @author Luciano M. Christofoletti <luciano@objectware.net>
 * @since 21/oct/2015
 */
public class BinaryExporterDialog extends javax.swing.JDialog implements ActionListener {
    
    /** The export file chooser */
    private JFileChooser exportFileChooser;
    
    /** The binary data object */
    private BinaryDataObject dataObject;
    
    /** The index vector of selected columns */
    private int[] selectedColumns;
    
    /** The index vector of selected rows */
    private int[] selectedRows;
    
    /**
     * Creates new form BinaryExporterDialog
     */
    public BinaryExporterDialog(java.awt.Frame parent, boolean modal) {
        
        super(parent, modal);
        
        this.initComponents();
        this.setupListeners();
        this.setTitle(I18N.getString("export.binary.data"));
        
        // initialize text fields
        this.exportAsComboBox.removeItem(ExportFormat.IMAGE);
        this.elementsPerLineTextField.setText(Integer.toString(Default.HEX_TABLE_WIDTH));
        this.linePrefixTextField.setText(Default.ASM_DATA_BYTES);
    }   
    
    /** Setup dialog listeners */
    private void setupListeners() {
        
        // setup combo box listeners
        this.exportAsComboBox.addActionListener(this);
        
        // setup buttons listeners
        this.selectOutputFileButton.addActionListener(this);
        this.exportButton.addActionListener(this);
        this.cancelButton.addActionListener(this);
    }   
    
    /**
     * Set the binary data object.
     * @param dataObject 
     */
    public void setDataObject(BinaryDataObject dataObject) {
        this.dataObject = dataObject;
    }
    
    /**
     * Sets the current selected indexes.
     * @param rows the indexes of selected rows
     * @param columns the indexes of selected columns
     */
    public void setSelection(int[] rows, int[] columns) {
        
        // reset the current selection
        this.selectedRows = null;
        this.selectedColumns = null;
        
        // enable selection export only when there are seleted data
        if(rows != null && columns != null && (rows.length > 1 || columns.length > 1)) {
            this.selectedRows = rows.clone();
            this.selectedColumns = columns.clone();
            this.exportSelectionOnlyCheckBox.setEnabled(true);
        } else {
            this.exportSelectionOnlyCheckBox.setEnabled(false);
            this.exportSelectionOnlyCheckBox.setSelected(false);
        }
    }   
    
    /**
     * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The
     * content of this method is always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        mainPanel = new javax.swing.JPanel();
        exportAsLabel = new javax.swing.JLabel();
        exportAsComboBox = new javax.swing.JComboBox();
        outputFileLabel = new javax.swing.JLabel();
        outputFileTextField = new javax.swing.JTextField();
        selectOutputFileButton = new javax.swing.JButton();
        linePrefixLabel = new javax.swing.JLabel();
        linePrefixTextField = new javax.swing.JTextField();
        dataFormatLabel = new javax.swing.JLabel();
        dataFormatComboBox = new javax.swing.JComboBox();
        elementsPerLineLabel = new javax.swing.JLabel();
        elementsPerLineTextField = new javax.swing.JTextField();
        exportSelectionOnlyCheckBox = new javax.swing.JCheckBox();
        buttonsPanel = new javax.swing.JPanel();
        exportButton = new javax.swing.JButton();
        cancelButton = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setMinimumSize(new java.awt.Dimension(512, 240));
        setPreferredSize(new java.awt.Dimension(608, 240));

        mainPanel.setPreferredSize(new java.awt.Dimension(480, 138));

        org.openide.awt.Mnemonics.setLocalizedText(exportAsLabel, I18N.getString("export.as"));

        exportAsComboBox.setModel(new javax.swing.DefaultComboBoxModel(ExportFormat.values()));
        exportAsComboBox.setActionCommand(ExportDialogAction.EXPORT_AS.name());

        org.openide.awt.Mnemonics.setLocalizedText(outputFileLabel, I18N.getString("output.file"));

        org.openide.awt.Mnemonics.setLocalizedText(selectOutputFileButton, I18N.getString("select")
        );
        selectOutputFileButton.setActionCommand(ExportDialogAction.SELECT_FILE.name());

        org.openide.awt.Mnemonics.setLocalizedText(linePrefixLabel, I18N.getString("line.prefix"));

        org.openide.awt.Mnemonics.setLocalizedText(dataFormatLabel, I18N.getString("data.format"));

        dataFormatComboBox.setModel(new javax.swing.DefaultComboBoxModel(DataFormat.values()));

        org.openide.awt.Mnemonics.setLocalizedText(elementsPerLineLabel, I18N.getString("bytes.per.line"));

        exportSelectionOnlyCheckBox.setSelected(true);
        org.openide.awt.Mnemonics.setLocalizedText(exportSelectionOnlyCheckBox, I18N.getString("export.selection.only"));
        exportSelectionOnlyCheckBox.setPreferredSize(new java.awt.Dimension(160, 23));

        javax.swing.GroupLayout mainPanelLayout = new javax.swing.GroupLayout(mainPanel);
        mainPanel.setLayout(mainPanelLayout);
        mainPanelLayout.setHorizontalGroup(
            mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(mainPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(outputFileLabel)
                    .addComponent(linePrefixLabel)
                    .addComponent(elementsPerLineLabel)
                    .addComponent(exportAsLabel))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(mainPanelLayout.createSequentialGroup()
                        .addComponent(outputFileTextField)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(selectOutputFileButton))
                    .addGroup(mainPanelLayout.createSequentialGroup()
                        .addComponent(linePrefixTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(dataFormatLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(dataFormatComboBox, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addComponent(exportAsComboBox, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(mainPanelLayout.createSequentialGroup()
                        .addComponent(elementsPerLineTextField, javax.swing.GroupLayout.PREFERRED_SIZE, 80, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(exportSelectionOnlyCheckBox, javax.swing.GroupLayout.DEFAULT_SIZE, 352, Short.MAX_VALUE)))
                .addContainerGap())
        );
        mainPanelLayout.setVerticalGroup(
            mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(mainPanelLayout.createSequentialGroup()
                .addGap(9, 9, 9)
                .addGroup(mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(exportAsLabel)
                    .addComponent(exportAsComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(outputFileLabel)
                    .addComponent(outputFileTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(selectOutputFileButton))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(linePrefixTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(linePrefixLabel)
                    .addComponent(dataFormatLabel)
                    .addComponent(dataFormatComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(mainPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(elementsPerLineTextField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(elementsPerLineLabel)
                    .addComponent(exportSelectionOnlyCheckBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        getContentPane().add(mainPanel, java.awt.BorderLayout.CENTER);

        buttonsPanel.setMinimumSize(new java.awt.Dimension(0, 0));
        buttonsPanel.setPreferredSize(new java.awt.Dimension(480, 38));
        buttonsPanel.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.RIGHT, 8, 4));

        org.openide.awt.Mnemonics.setLocalizedText(exportButton, I18N.getString("export"));
        exportButton.setActionCommand(ExportDialogAction.EXPORT.name());
        buttonsPanel.add(exportButton);

        org.openide.awt.Mnemonics.setLocalizedText(cancelButton, I18N.getString("cancel")
        );
        cancelButton.setActionCommand(ExportDialogAction.CANCEL.name());
        buttonsPanel.add(cancelButton);

        getContentPane().add(buttonsPanel, java.awt.BorderLayout.PAGE_END);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel buttonsPanel;
    private javax.swing.JButton cancelButton;
    private javax.swing.JComboBox dataFormatComboBox;
    private javax.swing.JLabel dataFormatLabel;
    private javax.swing.JLabel elementsPerLineLabel;
    private javax.swing.JTextField elementsPerLineTextField;
    private javax.swing.JComboBox exportAsComboBox;
    private javax.swing.JLabel exportAsLabel;
    private javax.swing.JButton exportButton;
    private javax.swing.JCheckBox exportSelectionOnlyCheckBox;
    private javax.swing.JLabel linePrefixLabel;
    private javax.swing.JTextField linePrefixTextField;
    private javax.swing.JPanel mainPanel;
    private javax.swing.JLabel outputFileLabel;
    private javax.swing.JTextField outputFileTextField;
    private javax.swing.JButton selectOutputFileButton;
    // End of variables declaration//GEN-END:variables

    @Override
    public void actionPerformed(ActionEvent event) {
        
        // get the dialog action "type"
        ExportDialogAction action = ExportDialogAction.valueOf(event.getActionCommand());
        
        switch(action) {
            
            case SELECT_FILE:
                this.selectOutputFile();
                break;
                
            case EXPORT:
                this.exportBinaryData();
                break;
                
            case EXPORT_AS:
                this.updateDialogView();
                break;
                
            case CANCEL:
                this.setVisible(false);
                break;
        }
    }
    
    /**
     * Export binary data file using the selected format.
     */
    private void exportBinaryData() {
        
        java.awt.Frame mainWindow = WindowManager.getDefault().getMainWindow();
        
        // validate the selected file name field
        String outputFileName = this.outputFileTextField.getText();
        if(outputFileName == null || outputFileName.isEmpty()) {
            JOptionPane.showMessageDialog(mainWindow,
                I18N.getString("please.select.output.file"), // message
                I18N.getString("export"), // title
                JOptionPane.INFORMATION_MESSAGE);
            return;
        }   
        
        // validate the number of bytes per line field
        try {
            if(Integer.parseInt(this.elementsPerLineTextField.getText()) < 1) {
                throw new NumberFormatException();
            }
        } catch(NumberFormatException nfe) {
            String field = this.elementsPerLineLabel.getText().replace(':', ' ').trim().toLowerCase();
            JOptionPane.showMessageDialog(mainWindow,
                I18N.getString("invalid.integer.number.format", field), // message
                I18N.getString("invalid.parameter.value"), // title
                JOptionPane.ERROR_MESSAGE);
            return;
        }   
        
        // create a new empty target file using the selected output file name
        File targetFile = new File(outputFileName);
        ExportFormat format = (ExportFormat) this.exportAsComboBox.getSelectedItem();
        
        // get the binary data to be exported
        final byte[] binaryData;
        if(this.exportSelectionOnlyCheckBox.isSelected()) {
            binaryData = this.getSelectedData();
        } else {
            binaryData = this.dataObject.getData();
        }   
        
        try {
            // verify if the selected file name already exists or it can be created
            if(!FileUtil.createNewFile(this, targetFile)) {
                return;
            }
            
            switch(format) {
                
                case ASSEMBLY:
                    this.exportAssemblyCode(targetFile, binaryData);
                    break;
                    
                case BINARY:
                    this.exportBinaryData(targetFile, binaryData);
                    break;
                    
                default:
                    throw new RuntimeException("Option not available: " + format);
            }   
            
            // close the export dialog window and show the export success message
            this.setVisible(false);
            JOptionPane.showMessageDialog(mainWindow,
                I18N.getString("sprite.data.export.sucessful", targetFile.getName()), // message
                I18N.getString("export"), // title
                JOptionPane.INFORMATION_MESSAGE);
            
        } catch (IOException ioException) {
            JOptionPane.showMessageDialog(mainWindow,
                I18N.getString("error.writing.file", targetFile.getPath()), // dialog message
                I18N.getString("input.output.error"), // dialog title
                JOptionPane.ERROR_MESSAGE);
        }   
    }
    
    /**
     * Export the binary data to an assembly data file.
     * @param exportFile the output file
     * @param binaryData the binary data to be exported
     * @throws IOException if some error occurs
     */
    private void exportAssemblyCode(File exportFile, byte[] binaryData) throws IOException {
       
        // -------------------------------- export data as assembly code
        DataFileIOUtil dataFileIOUtil = Lookup.getDefault().lookup(DataFileIOUtil.class);
        dataFileIOUtil.setLinePrefix(this.linePrefixTextField.getText());
        dataFileIOUtil.setDataFormat(((DataFormat) this.dataFormatComboBox.getSelectedItem()).getFormatter());
        dataFileIOUtil.setBytesPerLine(Integer.parseInt(this.elementsPerLineTextField.getText()));
        
        // translate the binary data to assembly code
        List<String> lines = new ArrayList<>();
        
        // generate the lines to be exported
        lines.add(Default.ASM_COMMENT_STRING + Default.SPACE_STRING + Default.COPYRIGHT);
        lines.add(Default.ASM_COMMENT_STRING + Default.SPACE_STRING + 
            I18N.getString("export.from", this.dataObject.getPrimaryFile().getNameExt()));
        lines.add(Default.EMPTY_STRING);
        lines.addAll(dataFileIOUtil.translate(binaryData));
        
        // write the file to disk
        dataFileIOUtil.write(exportFile.getCanonicalPath(), lines);
    }   
    
    /**
     * Export the binary data to a binary file :P
     * @param exportFile the output file
     * @param binaryData the binary data to be exported
     */
    private void exportBinaryData(File exportFile, byte[] binaryData) throws IOException {
        
        // get the binary file I/O util object
        BinaryFileIOUtil binaryFileIOUtil = Lookup.getDefault().lookup(BinaryFileIOUtil.class);
        
        // -------------------------------- export data to a binary file
        try (OutputStream outputStream = binaryFileIOUtil.createOutputStream(exportFile)) {
            outputStream.write(binaryData);
            outputStream.flush();
        }   
    }
    
    /**
     * Update the dialog visual status accordingly to the selected export format.
     */
    private void updateDialogView() {
        
        // exportFormat the format of export (asm code, binary file or image)
        ExportFormat exportFormat = (ExportFormat) this.exportAsComboBox.getSelectedItem();
        
        switch(exportFormat) {
            
            case ASSEMBLY:
                this.updateVisualElements(true);
                break;
                
            case BINARY:
                this.updateVisualElements(false);
                break;
                
            default:
                throw new RuntimeException("Option not available: " + exportFormat);
        }   
    }   
    
    /**
     * Enable/Disable the dialog visual components accordingly to the selected
     * export format.
     * @param status true = enable, false = disable
     */
    private void updateVisualElements(boolean status) {
        this.elementsPerLineLabel.setEnabled(status);
        this.elementsPerLineTextField.setEnabled(status);
        this.linePrefixLabel.setEnabled(status);
        this.linePrefixTextField.setEnabled(status);
        this.dataFormatLabel.setEnabled(status);
        this.dataFormatComboBox.setEnabled(status);
    }   
    
    /**
     * Select the output file name.
     */
    private void selectOutputFile() {
        
        // set up the file chooser (if not created yet)
        if(this.exportFileChooser == null) {
            this.exportFileChooser = new JFileChooser();
            this.exportFileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
        }   
        
        // setup the file filter
        ExportFormat exportFormat = (ExportFormat) this.exportAsComboBox.getSelectedItem();
        FileType fileType = exportFormat.getFileType();
        FileNameExtensionFilter xmlFilter = new FileNameExtensionFilter(
            exportFormat.getFileType().getDescription(), fileType.getExtension()
        );
        //this.exportFileChooser.addChoosableFileFilter(xmlFilter);
        this.exportFileChooser.setFileFilter(xmlFilter);
        
        // show the file save chooser dialog
        int userOption = this.exportFileChooser.showSaveDialog(this);
        
        // process the results
        if (userOption == JFileChooser.APPROVE_OPTION) {
            
            // set the default file name extension to the selected format
            String filePath = FileUtil.adjustExtensionFileName(
                this.exportFileChooser.getSelectedFile().getAbsolutePath(), fileType.getExtension()
            );
            
            this.outputFileTextField.setText(filePath);
        }   
    }
    
    /**
     * Get the current selected data from given indexes selection.
     * @return the selected table data as a byte array
     */
    private byte[] getSelectedData() {
        
        List<Byte> data = new ArrayList<>();
        
        // select the bytes to export
        for (int row : this.selectedRows) {
            for (int column : this.selectedColumns) {
                try {
                    data.add(this.dataObject.getValueAt(row, column));
                } catch (IndexOutOfBoundsException exception) {
                    // nothing to do. This exception may occur at the end of file
                    // when the binary file size is not a multiple of table width
                    break;
                }
            }
        }
        
        // fill the binary data array with the selected data
        byte[] binaryData = new byte[data.size()];
        for (int i = 0; i < data.size(); i++) {
            binaryData[i] = data.get(i);
        }
        
        return binaryData;
    }
}
